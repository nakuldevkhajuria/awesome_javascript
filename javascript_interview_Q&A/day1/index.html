<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="index.css">
</head>
<body>
    

    Question 1: Difference between “ == “ and “ === “ operators.

    <pre>
        The main difference between the == and === operator in javascript is that the == operator does the type 
        conversion of the operands before comparison, whereas the === operator compares the values as well as the
        data types of the operands.

        Means, if a and b are the operands, one is string and another number. we are using == then, numeric type varible
        will be converted into string for comparision.

        == operator triggers numeric conversion, string 'true' is converted to NaN, boolean true is converted to 1. 
        == usually triggers numeric conversion, but it's not the case with null . 
        null equals to null or undefined only, and does not equal to anything else.

        it goes from left to right.

        <a target="_blank" href="https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839/#:~:text===%20operator%20triggers%20numeric%20conversion,true%20is%20converted%20to%201.&text===%20usually%20triggers%20numeric%20conversion,not%20equal%20to%20anything%20else.">Link to Understand More.</a>
    </pre>
    Question 2: What is the spread operator?

    <pre>
        

        let array = [1,4,3,2,5,5,3]
        console.log(...array)
        let array1 = [1,4,'raju',2,'is my',5,'name']
        console.log(`${array1[2]} ${array1[4]} ${array1[6]}`)
        
        let combine= [...array,...array1]
        console.log(combine)


        
        // changed the original array
        let arr = ['a','b','c'];
        let arr2 = arr;
  
        arr2.push('d');
  
        console.log(arr2);
        console.log(arr); // even affected the original array(arr) 

        spreadOperator solves this problem of change in orignal array 
        By using the spread operator we made sure that the original array is not affected whenever we alter the new array.

        we can also combine objects using spreadOperator
        const user1 = {
            name: 'Jen',
            age: 22,
        };
          
        const user2 = {
            name: "Andrew",
            location: "Philadelphia" 
        };
          
        const mergedUsers = {...user1, ...user2};
        console.log(mergedUsers)
        <!-- //name Andrew age: location?????  howww-->
        Actually, every enumerable property on the objects will be copied to mergedUsers object. 
        Enumerable properties are those properties whose internal enumerable flag is set to true


    </pre>

    Question 3: What are the differences between var, let and const?

    <pre>
    let - 1. we can declare the variable name in one line and initialize it on another line 
        // or in the same line itself.
        // 2. Two variables with same name aren't possible with let
        // 3. We can reassign/update the values of the variable which have already been initialized.
        // 4. let is block scoped. 
        // 5. Let doesn't supports Hoisting.

    const - 1. we have to declare the variable and initialize in the same line itself.
        // 2. Two variables with same name aren't possible with const.
        // 3. We can't reassign/update the values of the variable which have already been initialized.
        // 4. const is block scoped. 
        // 5. const also doesn't supports Hoisting.
    var - 1. we can declare the variable name in one line and initialize it on another line 
        // or in the same line itself.
        // 2. Two variables with same name are possible with var
        // 3. We can reassign/update the values of the variable which have already been initialized.
        // 4. var is global scoped. 
        // 5. var supports Hoisting.


    </pre>
    Question 4: What is execution context

    <pre>
        The Execution Context contains the code that's currently running, and everything that aids in its execution.
        During the Execution Context run-time, the specific code gets parsed by a parser, the variables and functions are
        stored in memory, executable byte-code gets generated, and the code gets executed.

    </pre>
    Question 5: What is creation phase and execution phase?

    <pre>
        When a global code / function / eval is executed it goes through the below phase,

    
    1. Creation Phase

    Compiler runs through the entire code for 2 time before actually executing the code,

    In the first run, It picks all function declarations and stores them in memory with their reference.
    In the second run, It picks all variables and assign undefined to them. In the event of a conflict between variable and function declaration name then that variable is ignored.

    2. Execution Phase

        1. Variables assigned with values
        2. Functions executed


        <a href="https://medium.com/@sudhakarsp06/creation-phase-and-execution-phase-in-javascript-32fcdbef60f4" target="_blank" >Link to Understand More.</a>
    </pre>
    Question 6: What is meant by first class functions

    <pre>

        in simple terms FCF are passed as arguments in another function.

        For example, in such a language, a function can be passed as an argument to other functions,
        can be returned by another function and can be assigned as a value to a variable.
        FCF functions are passed in a function which we call higher class function

    </pre>
    Question 7: What are closures? Give an example of closure
    <pre>
        A closure is the combination of a function bundled together (enclosed) with references to its surrounding state 
        (the lexical environment). In other words, a closure gives you access to an outer function's scope from an inner
         function.

         in simple terms, inner functions has the power to access the outer(the lexical environment) function variables. and also remember it.

         function makeFunc() {
            const name = 'Mozilla';
            function displayName(name) {
              console.log(name);
            }
            return displayName;
          }
          
          const myFunc = makeFunc();//myFunc is assigned to the inner function
          myFunc();//Mozilla
          myFunc('helo');//helo

          <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="noopener noreferrer">Check for more examples</a>

        </pre>
          
</body>
</html>